this.seq <- i * 96 + 1:96
plot( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, ylab = "Solar kW", type = "n", main = formatted.time[this.seq[1]] ) # Checking first data for oscillation pathology
lines( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, col = "green" ) # Checking first data for oscillation pathology
this.formatted.time <- formatted.time[this.seq]
this.formatted.time[1]
this.formatted.time[96]
i <- i + 1
this.seq <- i * 96 + 1:96
plot( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, ylab = "Solar kW", type = "n", main = formatted.time[this.seq[1]] ) # Checking first data for oscillation pathology
lines( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, col = "green" ) # Checking first data for oscillation pathology
this.formatted.time <- formatted.time[this.seq]
this.formatted.time[1]
this.formatted.time[96]
i <- i + 1
this.seq <- i * 96 + 1:96
plot( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, ylab = "Solar kW", type = "n", main = formatted.time[this.seq[1]] ) # Checking first data for oscillation pathology
lines( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, col = "green" ) # Checking first data for oscillation pathology
this.formatted.time <- formatted.time[this.seq]
this.formatted.time[1]
this.formatted.time[96]
i <- i + 1
this.seq <- i * 96 + 1:96
plot( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, ylab = "Solar kW", type = "n", main = formatted.time[this.seq[1]] ) # Checking first data for oscillation pathology
lines( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, col = "green" ) # Checking first data for oscillation pathology
this.formatted.time <- formatted.time[this.seq]
this.formatted.time[1]
this.formatted.time[96]
i <- i + 1
this.seq <- i * 96 + 1:96
plot( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, ylab = "Solar kW", type = "n", main = formatted.time[this.seq[1]] ) # Checking first data for oscillation pathology
lines( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, col = "green" ) # Checking first data for oscillation pathology
this.formatted.time <- formatted.time[this.seq]
this.formatted.time[1]
this.formatted.time[96]
# Get sums for Excel spreadsheet
sum( solar.data$KWH[base.low.peak.array == "high"] )
sum( solar.data$KWH[base.low.peak.array == "low"] )
sum( solar.data$KWH[base.low.peak.array == "base"] )
sum( solar.data$KWH )
# These numbers should match the LADWP numbers
sum( college.data$KWH[base.low.peak.array == "high"] )
max( college.data$KWH[base.low.peak.array == "high"] ) / 0.25
sum( college.data$KWH[base.low.peak.array == "low"] )
max( college.data$KWH[base.low.peak.array == "low"] ) / 0.25
sum( college.data$KWH[base.low.peak.array == "base"] )
# Initialize
setwd( "/Users/ifft/Documents/Solar@Oxy/Solar Data" )
rm( list = ls() )
source( "/users/ifft/documents/measurement.r" )
# Make up a new AlsoEnergy file
first.day <- 20211207
last.day <- 20220109 # Put in one less the last day of the bill here
chart.filename <- "/Users/ifft/Documents/Solar@Oxy/Solar Data/MVWeb Monthly Data/chart-data.csv"
filename <- paste( "/Users/ifft/Documents/Solar@Oxy/Solar Data/MVWeb Monthly Data/dataout_AlsoEnergy_V2_", first.day, "-", last.day, ".csv", sep = "" )
file.rename( from = chart.filename, to = filename)
# Get all of the filenames
solar.filenames <- system( "ls ./'MVWeb Monthly Data' | grep 4261801", intern = TRUE )
solar.filenames <- c( solar.filenames, system( "ls ./'MVWeb Monthly Data' | grep dataout_AlsoEnergy_", intern = TRUE ) )
college.filenames <- system( "ls ./'MVWeb Monthly Data' | grep 4022135", intern = TRUE )
college.filenames <- c( college.filenames, system( "ls ./'MVWeb Monthly Data' | grep 4022142", intern = TRUE ) ) # Change of meter in October 2016
college.filenames <- c( college.filenames, system( "ls ./'MVWeb Monthly Data' | grep 4022156", intern = TRUE ) ) # Change of meter in September 2021
# Check for no length errors
cbind( solar.filenames, college.filenames )
# Get all of the filenames
solar.filenames <- system( "ls ./'MVWeb Monthly Data' | grep 4261801", intern = TRUE )
solar.filenames <- c( solar.filenames, system( "ls ./'MVWeb Monthly Data' | grep dataout_AlsoEnergy_", intern = TRUE ) )
college.filenames <- system( "ls ./'MVWeb Monthly Data' | grep 4022135", intern = TRUE )
college.filenames <- c( college.filenames, system( "ls ./'MVWeb Monthly Data' | grep 4022142", intern = TRUE ) ) # Change of meter in October 2016
college.filenames <- c( college.filenames, system( "ls ./'MVWeb Monthly Data' | grep 4022156", intern = TRUE ) ) # Change of meter in September 2021
# Check for no length errors
cbind( solar.filenames, college.filenames )
# Select latest file
solar.filename <- solar.filenames[length(solar.filenames)] # for the latest
solar.filename
source( "load.solar.data.r" )
college.filename <- college.filenames[length(college.filenames)] # for the latest
college.filename
source( "load.college.data.r" ) # Prefer to use college times for formatted.time
source( "assign.base.low.peak.r" )
# Check that the arrays are the same length
length( college.data$KWH ) == length( solar.data$KWH )
# Check college data
plot( formatted.time, college.data$KWH / 0.25, ylab = "College kW", type = "n", main = solar.filename )
max.formatted.time <- formatted.time[college.data$KWH==max(college.data$KWH)]
for ( i in 1:length( max.formatted.time ) ) { # in case of ties
lines( c( max.formatted.time[i], max.formatted.time[i] ), c( -100, 3000 ), col = "tan")
}
lines( formatted.time, college.data$KWH / 0.25, col = "brown" )
# Check solar data
plot( formatted.time, solar.data$KWH / 0.25, ylab = "Solar kW", type = "n", main = solar.filename )
for ( i in 1:length( max.formatted.time ) ) { # in case of ties
lines( c( max.formatted.time[i], max.formatted.time[i] ), c( -100, 3000 ), col = "tan")
}
lines( formatted.time, solar.data$KWH / 0.25, col = "green" )
# Check for pathologies.  Should be smoorth.
i <- -1
i <- i + 1
this.seq <- i * 96 + 1:96
plot( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, ylab = "Solar kW", type = "n", main = formatted.time[this.seq[1]] ) # Checking first data for oscillation pathology
lines( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, col = "green" ) # Checking first data for oscillation pathology
this.formatted.time <- formatted.time[this.seq]
this.formatted.time[1]
this.formatted.time[96]
i <- i + 1
this.seq <- i * 96 + 1:96
plot( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, ylab = "Solar kW", type = "n", main = formatted.time[this.seq[1]] ) # Checking first data for oscillation pathology
lines( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, col = "green" ) # Checking first data for oscillation pathology
this.formatted.time <- formatted.time[this.seq]
this.formatted.time[1]
this.formatted.time[96]
i <- i + 1
this.seq <- i * 96 + 1:96
plot( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, ylab = "Solar kW", type = "n", main = formatted.time[this.seq[1]] ) # Checking first data for oscillation pathology
lines( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, col = "green" ) # Checking first data for oscillation pathology
this.formatted.time <- formatted.time[this.seq]
this.formatted.time[1]
this.formatted.time[96]
i <- i + 1
this.seq <- i * 96 + 1:96
plot( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, ylab = "Solar kW", type = "n", main = formatted.time[this.seq[1]] ) # Checking first data for oscillation pathology
lines( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, col = "green" ) # Checking first data for oscillation pathology
this.formatted.time <- formatted.time[this.seq]
this.formatted.time[1]
this.formatted.time[96]
i <- i + 1
this.seq <- i * 96 + 1:96
plot( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, ylab = "Solar kW", type = "n", main = formatted.time[this.seq[1]] ) # Checking first data for oscillation pathology
lines( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, col = "green" ) # Checking first data for oscillation pathology
this.formatted.time <- formatted.time[this.seq]
this.formatted.time[1]
this.formatted.time[96]
i <- i + 1
this.seq <- i * 96 + 1:96
plot( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, ylab = "Solar kW", type = "n", main = formatted.time[this.seq[1]] ) # Checking first data for oscillation pathology
lines( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, col = "green" ) # Checking first data for oscillation pathology
this.formatted.time <- formatted.time[this.seq]
this.formatted.time[1]
this.formatted.time[96]
# Get sums for Excel spreadsheet
sum( solar.data$KWH[base.low.peak.array == "high"] )
sum( solar.data$KWH[base.low.peak.array == "low"] )
sum( solar.data$KWH[base.low.peak.array == "base"] )
sum( solar.data$KWH )
# These numbers should match the LADWP numbers
sum( college.data$KWH[base.low.peak.array == "high"] )
max( college.data$KWH[base.low.peak.array == "high"] ) / 0.25
sum( college.data$KWH[base.low.peak.array == "low"] )
max( college.data$KWH[base.low.peak.array == "low"] ) / 0.25
sum( college.data$KWH[base.low.peak.array == "base"] )
# Calculate monthly demand differential
# Enter negative numbers as 0.
max( ( college.data$KWH[base.low.peak.array == "high"] + solar.data$KWH[base.low.peak.array == "high"] ) / 0.25 ) - max( college.data$KWH[base.low.peak.array == "high"] / 0.25 )
max( ( college.data$KWH[base.low.peak.array == "low"] + solar.data$KWH[base.low.peak.array == "low"] ) / 0.25 ) - max( college.data$KWH[base.low.peak.array == "low"] / 0.25 )
# Load up multiple month files for facilities charge, this works.
solar.data.kwh.all <- NULL
college.data.kwh.all <- NULL
formatted.time.all <- NULL
for ( i in ( length( college.filenames ) - 11 ):( length( college.filenames ) ) ) {
college.filename <- college.filenames[i]
print( paste( "Loading ", college.filename, sep = "" ) )
source( "load.college.data.r" ) # Prefer to use college times for formatted.time
plot( formatted.time, college.data$KWH / 0.25, ylim = c( 0, 3000 ), ylab = "College kW", type = "n", main = college.filename )
lines( formatted.time, college.data$KWH / 0.25, col = "brown" )
college.data.kwh.all <- c( college.data.kwh.all, college.data$KWH )
formatted.time.all <- c( formatted.time.all, college.data$timestamp) # Collect all the strings first
solar.filename <- solar.filenames[i]
print( paste( "Loading ", solar.filename, sep = "" ) )
source( "load.solar.data.r" )
lines( formatted.time, solar.data$KWH / 0.25, col = "green" )
solar.data.kwh.all <- c( solar.data.kwh.all, solar.data$KWH )
}
length( college.data.kwh.all ) == length( solar.data.kwh.all )
length( solar.data.kwh.all ) # this should be around 35,000
formatted.time.all <- strptime( formatted.time.all, "%m/%d/%y %H:%M") #POSIXlt
max( ( college.data.kwh.all + solar.data.kwh.all ) / 0.25 ) - max( college.data.kwh.all / 0.25 )
plot( formatted.time.all, (college.data.kwh.all+solar.data.kwh.all)/(0.25*1000), ylim = c( 0, 4.0 ), type = "n", xlab = "Last year", ylab = "Power (MW)" )
college.max.time <- formatted.time.all[college.data.kwh.all == max( college.data.kwh.all )]
college.max.time
lines( c( college.max.time, college.max.time ), c( -100, 100 ), lty = 2, col = "orange" )
abline( h = max( college.data.kwh.all )/(0.25*1000), col = "orange" )
solar.max.time <- formatted.time.all[(college.data.kwh.all+solar.data.kwh.all) == max(college.data.kwh.all+solar.data.kwh.all)]
max(college.data.kwh.all+solar.data.kwh.all)/(0.25*1000)
solar.max.time
lines( c( solar.max.time, solar.max.time ), c( -100, 100 ), lty = 2, col = "brown" )
abline( h = max(college.data.kwh.all+solar.data.kwh.all)/(0.25*1000), col = "brown" )
#abline( h = mean( (college.data.kwh.all+solar.data.kwh.all)/(0.25*1000) ), col = "brown" )
#abline( h = mean( (solar.data.kwh.all)/(0.25*1000) ), col = "green" )
lines( formatted.time.all, (college.data.kwh.all+solar.data.kwh.all)/(0.25*1000), col = "brown" )
lines( formatted.time.all, (college.data.kwh.all)/(0.25*1000), col = "orange" )
lines( formatted.time.all, (solar.data.kwh.all)/(0.25*1000), col = "green" )
abline( h = 0 )
# Get all of the filenames
solar.filenames <- system( "ls ./'MVWeb Monthly Data' | grep 4261801", intern = TRUE )
solar.filenames <- c( solar.filenames, system( "ls ./'MVWeb Monthly Data' | grep dataout_AlsoEnergy_", intern = TRUE ) )
college.filenames <- system( "ls ./'MVWeb Monthly Data' | grep 4022135", intern = TRUE )
college.filenames <- c( college.filenames, system( "ls ./'MVWeb Monthly Data' | grep 4022142", intern = TRUE ) ) # Change of meter in October 2016
college.filenames <- c( college.filenames, system( "ls ./'MVWeb Monthly Data' | grep 4022156", intern = TRUE ) ) # Change of meter in September 2021
# Check for no length errors
cbind( solar.filenames, college.filenames )
# Select latest file
solar.filename <- solar.filenames[length(solar.filenames)] # for the latest
solar.filename
source( "load.solar.data.r" )
college.filename <- college.filenames[length(college.filenames)] # for the latest
college.filename
source( "load.college.data.r" ) # Prefer to use college times for formatted.time
source( "assign.base.low.peak.r" )
# Select latest file
solar.filename <- solar.filenames[length(solar.filenames)] # for the latest
solar.filename
source( "load.solar.data.r" )
college.filename <- college.filenames[length(college.filenames)] # for the latest
college.filename
source( "load.college.data.r" ) # Prefer to use college times for formatted.time
source( "assign.base.low.peak.r" )
# Check that the arrays are the same length
length( college.data$KWH ) == length( solar.data$KWH )
# Check college data
plot( formatted.time, college.data$KWH / 0.25, ylab = "College kW", type = "n", main = solar.filename )
max.formatted.time <- formatted.time[college.data$KWH==max(college.data$KWH)]
for ( i in 1:length( max.formatted.time ) ) { # in case of ties
lines( c( max.formatted.time[i], max.formatted.time[i] ), c( -100, 3000 ), col = "tan")
}
lines( formatted.time, college.data$KWH / 0.25, col = "brown" )
# Check solar data
plot( formatted.time, solar.data$KWH / 0.25, ylab = "Solar kW", type = "n", main = solar.filename )
for ( i in 1:length( max.formatted.time ) ) { # in case of ties
lines( c( max.formatted.time[i], max.formatted.time[i] ), c( -100, 3000 ), col = "tan")
}
lines( formatted.time, solar.data$KWH / 0.25, col = "green" )
# Check for pathologies.  Should be smoorth.
i <- -1
i <- i + 1
this.seq <- i * 96 + 1:96
plot( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, ylab = "Solar kW", type = "n", main = formatted.time[this.seq[1]] ) # Checking first data for oscillation pathology
lines( formatted.time[this.seq], solar.data$KWH[this.seq] / 0.25, col = "green" ) # Checking first data for oscillation pathology
this.formatted.time <- formatted.time[this.seq]
this.formatted.time[1]
this.formatted.time[96]
# Get sums for Excel spreadsheet
sum( solar.data$KWH[base.low.peak.array == "high"] )
sum( solar.data$KWH[base.low.peak.array == "low"] )
sum( solar.data$KWH[base.low.peak.array == "base"] )
sum( solar.data$KWH )
# These numbers should match the LADWP numbers
sum( college.data$KWH[base.low.peak.array == "high"] )
max( college.data$KWH[base.low.peak.array == "high"] ) / 0.25
sum( college.data$KWH[base.low.peak.array == "low"] )
max( college.data$KWH[base.low.peak.array == "low"] ) / 0.25
sum( college.data$KWH[base.low.peak.array == "base"] )
# Calculate monthly demand differential
# Enter negative numbers as 0.
max( ( college.data$KWH[base.low.peak.array == "high"] + solar.data$KWH[base.low.peak.array == "high"] ) / 0.25 ) - max( college.data$KWH[base.low.peak.array == "high"] / 0.25 )
max( ( college.data$KWH[base.low.peak.array == "low"] + solar.data$KWH[base.low.peak.array == "low"] ) / 0.25 ) - max( college.data$KWH[base.low.peak.array == "low"] / 0.25 )
# Load up multiple month files for facilities charge, this works.
solar.data.kwh.all <- NULL
college.data.kwh.all <- NULL
formatted.time.all <- NULL
for ( i in ( length( college.filenames ) - 11 ):( length( college.filenames ) ) ) {
college.filename <- college.filenames[i]
print( paste( "Loading ", college.filename, sep = "" ) )
source( "load.college.data.r" ) # Prefer to use college times for formatted.time
plot( formatted.time, college.data$KWH / 0.25, ylim = c( 0, 3000 ), ylab = "College kW", type = "n", main = college.filename )
lines( formatted.time, college.data$KWH / 0.25, col = "brown" )
college.data.kwh.all <- c( college.data.kwh.all, college.data$KWH )
formatted.time.all <- c( formatted.time.all, college.data$timestamp) # Collect all the strings first
solar.filename <- solar.filenames[i]
print( paste( "Loading ", solar.filename, sep = "" ) )
source( "load.solar.data.r" )
lines( formatted.time, solar.data$KWH / 0.25, col = "green" )
solar.data.kwh.all <- c( solar.data.kwh.all, solar.data$KWH )
}
length( college.data.kwh.all ) == length( solar.data.kwh.all )
length( solar.data.kwh.all ) # this should be around 35,000
formatted.time.all <- strptime( formatted.time.all, "%m/%d/%y %H:%M") #POSIXlt
max( ( college.data.kwh.all + solar.data.kwh.all ) / 0.25 ) - max( college.data.kwh.all / 0.25 )
2497/9
setwd( "/Users/ifft/desktop/R Scripts" ) # Change for your computer and analysis directory
library( tiff )
img <- readTIFF("./Color Bars.tiff")
dim( img )
x.size <- dim( img )[2]
y.size <- dim( img )[1]
plot( 0, 0, xlim = c( 0, x.size ), ylim = c( 0, y.size ), type = "n" )
rasterImage( img, 0, 0, x.size, y.size ) # You may get a warning message.  Be patient.  There is a lot of data to handle.
plot( 0, 0, xlim = c( 0, x.size ), ylim = c( 0, y.size ), type = "n" )
rasterImage( img, 0, 0, x.size, y.size ) # You may get a warning message.  Be patient.  There is a lot of data to handle.
xy <- locator(1) # R will wait for you to click on the graph somewhere returning the xy coordinates
this.x <- round( xy$x )
this.x <- round( xy$x )
this.y <- round( y.size - xy$y ) # Note that the orgin for a picture is in the upper left!
img[ this.y, this.x, 1] # Red
img[ this.y, this.x, 2] # Green
img[ this.y, this.x, 3] # Blue
img[ this.y, this.x, 4]
# If you want to read off a line of pixel values in x just drop the x specification from the matrix
plot( 0, 0, xlim = c( 0, x.size ), ylim = c( 0, y.size ), type = "n" )
rasterImage( img, 0, 0, x.size, y.size ) # You may get a warning message.  Be patient.  There is a lot of data to handle.
xy <- locator(1) # R will wait for you to click on the graph somewhere returning the xy coordinates
this.y <- round( y.size - xy$y ) # We just want the y value this time
red.pixel.line <- img[ this.y, , 1] # Red
green.pixel.line <- img[ this.y, , 2] # Green
blue.pixel.line <- img[ this.y, , 3] # Blue
seq.pixel.line <- seq( red.pixel.line )
plot( seq.pixel.line, red.pixel.line, ylim = c( 0, 1 ), type = "n" ) # empty graph with the right dimensions
lines( seq.pixel.line, red.pixel.line, col = "red" )
lines( seq.pixel.line, green.pixel.line, col = "green" )
lines( seq.pixel.line, blue.pixel.line, col = "blue" )
# This code will allow you to do error propagation easily.
# Working directory
setwd( "/Users/ifft/Documents/P315F22/R Scripts" ) # Change for your computer and analysis directory
# R allows you to define new kinds of variables and to also define how they interaction with each other.
# For instance R has a predefined variable for
# complex numbers.  It knows how to multiply them properly.  Here's a simple example,
complex( 1, 1, 1 )
a <- complex( 1, 1, 1 )
b <- complex( 1, 1, -1 )
a * b
# I took advantage of this ability to define variables and how they interact to define a measurement variable.
# To get this to work you need to run measurement.r in the command window.
source( "/users/ifft/documents/measurement.r" )
# You will need to replace the full pathname to point to whereever you have stored the file on your computer.
# FYI "./measurement.r" would refer to where you started R or wherever getwd() is.  Either way the command above will
#
# You will need to replace the full pathname to point to whereever you have stored the file on your computer.
# FYI "./measurement.r" would refer to where you started R or wherever getwd() is.  Either way the command above will
# "load" the measurement functions into your current working session.
# To make a measurement variable you run,
measurement( 1, 0.1 )
# This creates a variable whose value is 1 and whose associated error is 0.1.  Notice that like complex numbers
# it prints out in a nice way.  measurement.r knows how to multiply measurements.
a <- measurement( 1, 0.1 )
b <- measurement( 2, 0.1 )
a * b
# Working directory
setwd( "/Users/ifft/Documents/P315F22/R Scripts" ) # Change for your computer and analysis directory
# R allows you to define new kinds of variables and to also define how they interaction with each other.
# For instance R has a predefined variable for
# complex numbers.  It knows how to multiply them properly.  Here's a simple example,
complex( 1, 1, 1 )
a <- complex( 1, 1, 1 )
a
b <- complex( 1, 1, -1 )
b
a * b
source( "/users/ifft/documents/measurement.r" )
measurement( 1, 0.1 )
a <- measurement( 1, 0.1 )
a
b <- measurement( 2, 0.1 )
b
a * b
a + b
a^2
b * sin( a^2 )
etwd( "C:\Users\wscar\Downloads\Files for distribution\Files for distribution\R Scripts" ) # Change for your computer and analysis directory
filename <- "F0010CH1.CSV"
scan( filename, skip = 18, sep = "," )
data.values <- scan( filename, skip = 18, sep = "," )
data.values[1:10]
matrix( data.values, ncol = 2, byrow = TRUE )
mat <- matrix( data.values, ncol = 2, byrow = TRUE )
mat[1,1]
mat[1,2]
mat[10,1]
times <- mat[,1] # there is a function called time so I try to avoid using it as a variable name
voltage <- mat[,2]
plot( times, voltage, type = "n", pch = 20, cex = 0.01, xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
lines( times, voltage, col = "green" )
mat <- matrix( scan( filename, skip = 18, sep = "," ), ncol = 2, byrow = TRUE )
plot( times, voltage, type = "n", pch = 20, cex = 0.01, xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
lines( times, voltage, col = "green" )
View(coords)
View(experiment)
View(fit)
View(hA)
View(h)
View(hN)
View(hN)
View(intercept)
View(ls.fit)
View(mat)
View(slope)
mat <- matrix( scan( filename, skip = 18, sep = "," ), ncol = 2, byrow = TRUE )
setwd( "C:\Users\wscar\Downloads\Files for distribution\Files for distribution\R Scripts" ) # Change for your computer and analysis directory
setwd( "C:\Users\wscar\Downloads\Files for distribution\Files for distribution\R Scripts" ) # Change for your computer and analysis directory
setwd( "C:/Users/wscar/Downloads/Files for distribution/Files for distribution/R Scripts" ) # Change for your computer and analysis directory
source( "C:/Users/wscar/Downloads/Files for distribution/Files for distribution/R Scripts" )
source( "C:/Users/wscar/Downloads/Files for distribution/Files for distribution/R Scripts" )
source( "C:/Users/wscar/Downloads/Files for distribution/Files for distribution/R Scripts/measurement.r" )
times <- seq( from = 0, to = 2, by = 0.1 )
times
voltage <- times * 5 + 2
voltage
plot( times, voltage )
voltage <- voltage + rnorm( length( voltage ), sd = 0.5 )
plot( times, voltage )
lsfit( times, voltage )
ls.fit <- lsfit( times, voltage )
View(ls.out)
abline( ls.fit )
ls.print( ls.fit )
ls.out <- ls.print( ls.fit )
fit.numbers <- unclass( unlist( ls.out$coef.table ) )
fit.numbers
b <- measurement( fit.numbers[1], fit.numbers[3] ) # intercept
b
m <- measurement( fit.numbers[2], fit.numbers[4] ) # slope
m
times <- seq( from = 0, to = 5, by = 0.1 )
times
voltage <- 2 + 3 * times^2 + 10 * sin( times ) # a crazy function but "linear" according the the above definition
voltage
plot( times, voltage )
voltage <- voltage + rnorm( length( voltage ), sd = 0.5 )
plot( times, voltage )
lsfit( cbind( times^2, sin( times ) ), voltage )
ls.fit <- lsfit( cbind( times^2, sin( times ) ), voltage )
ls.fit <- lsfit( cbind( times^2, sin( times ) ), voltage )
ls.print( ls.fit )
ls.out <- ls.print( ls.fit )
fit.numbers <- unclass( unlist( ls.out$coef.table ) )
fit.numbers
x.fit <- seq( from = min( times ), to = max( times ), by = 0.01 )
y.fit <- fit.numbers[1] + fit.numbers[2] * x.fit^2 + fit.numbers[3] * sin( x.fit )
lines( x.fit, y.fit, col = "dark green" )
x.values <- rnorm( 1000, mean = 1, sd = 0.5 ) # Gaussian distribution with a mean of 1 and a standard deviation of 0.5
delta.x <- 0.1
hist( x.values, breaks = seq( from = min( x.values ) - delta.x, to = max( x.values ) + delta.x, by = delta.x ) ) # save the output
h <- hist( x.values, breaks = seq( from = min( x.values ) - delta.x, to = max( x.values ) + delta.x, by = delta.x ), plot = FALSE ) # save the output
points( h$mids, h$counts )
x <- h$mids
y <- h$counts
plot( x, y )
fit <- nls( y ~ A * exp( -( x - center )^2 / ( 2 * sigma^2 ) ), start = list( A = 80, center = 1, sigma = 0.5 ) )
summary( fit )
A <- coef(summary(fit))[1, "Estimate"]
center <- coef(summary(fit))[2, "Estimate"]
sigma <- coef(summary(fit))[3, "Estimate"]
A.err <- coef(summary(fit))[1, "Std. Error"]
center.err <- coef(summary(fit))[2, "Std. Error"]
sigma.err <- coef(summary(fit))[3, "Std. Error"]
measurement( A, A.err )
measurement( center, center.err )
measurement( sigma, sigma.err )
x.fit <- seq( from = min( x.values ) - delta.x, to = max( x.values ) + delta.x, by = delta.x / 10 )
y.fit <- A * exp( -( x.fit - center )^2 / ( 2 * sigma^2 ) )
hist( x.values, breaks = seq( from = min( x.values ) - delta.x, to = max( x.values ) + delta.x, by = delta.x ) ) # save the output
lines( x.fit, y.fit, col = "blue" )
setwd( "C:/Users/wscar/Downloads/Files for distribution/Files for distribution/R Scripts" ) # Change for your computer and analysis directory
# Load measurement.r.  See Using measurement.r .R to understand.
source( "C:/Users/wscar/Downloads/Files for distribution/Files for distribution/R Scripts/measurement.r" )
# Let's start with some "data"
times <- seq( from = 0, to = 2, by = 0.1 )
times
voltage <- sqrt( times )
voltage
# The basic plot command is just
plot( times, voltage )
# add titles
plot( times, voltage, xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
# change axes limits if you want
plot( times, voltage, xlim = c( -1, 3 ), ylim = c( -1, 3 ), xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
# draw small points instead of the default 0s
plot( times, voltage, pch = 20, cex = 0.5, xlim = c( -1, 3 ), ylim = c( -1, 3 ), xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
# don't draw the points, then draw a line
plot( times, voltage, type = "n", pch = 20, cex = 0.5, xlim = c( -1, 3 ), ylim = c( -1, 3 ), xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
lines( times, voltage )
# color is always nice
plot( times, voltage, type = "n", pch = 20, cex = 0.5, xlim = c( -1, 3 ), ylim = c( -1, 3 ), xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
# color is always nice
plot( times, voltage, type = "n", pch = 20, cex = 0.5, xlim = c( -1, 3 ), ylim = c( -1, 3 ), xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
lines( times, voltage, col = "green" )
You can do almost anything you want as far as plotting data in R.  Just ask Google "How do I XXX in R".
# one can always add other lines to the plot
times2 <- seq( from = 0, to = 2, by = 0.05 )
voltage2 <- times2
plot( times, voltage, type = "n", pch = 20, cex = 0.5, xlim = c( -1, 3 ), ylim = c( -1, 3 ), xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
lines( times, voltage, col = "green" )
lines( times2, voltage2, col = "red" )
plot( times, voltage, type = "n", pch = 20, cex = 0.5, xlim = c( -1, 3 ), ylim = c( -1, 3 ), xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
lines( times, voltage, col = "green" )
points( times, voltage, pch = 20, cex = 0.5, col = "green" )
lines( times2, voltage2, col = "red" )
points( times2, voltage2, pch = 20, cex = 0.5, col = "red" )
plot( times, voltage, type = "n", pch = 20, cex = 0.5, xlim = c( -1, 3 ), ylim = c( -1, 3 ), xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
lines( times, voltage, col = "green" )
points( times, voltage, pch = 20, cex = 0.5, col = "green" )
text( times[length(times)], voltage[length(voltage)], "Voltage", pos = 4 )
lines( times2, voltage2, col = "red" )
points( times2, voltage2, pch = 20, cex = 0.5, col = "red" )
text( times2[length(times2)], voltage2[length(voltage2)], "Voltage2", pos = 4 )
plot( times, voltage, type = "n", pch = 20, cex = 0.5, xlim = c( -1, 3 ), ylim = c( -1, 3 ), xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
lines( times, voltage, col = "green" )
points( times, voltage, pch = 20, cex = 0.5, col = "green" )
text( times[length(times)], voltage[length(voltage)], "Voltage", pos = 4 )
lines( times2, voltage2, col = "red" )
points( times2, voltage2, pch = 20, cex = 0.5, col = "red" )
text( times2[length(times2)], voltage2[length(voltage2)], "Voltage2", pos = 4 )
abline( h = 1, col = "purple")
abline( v = 1, col = "purple")
plot( times, voltage, type = "n", pch = 20, cex = 0.5, xlim = c( -1, 3 ), ylim = c( -1, 3 ), xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
lines( times, voltage, col = "green" )
points( times, voltage, pch = 20, cex = 0.5, col = "green" )
lines( times2, voltage2, col = "red" )
points( times2, voltage2, pch = 20, cex = 0.5, col = "red" )
legend( "topright", legend = c( "Voltage", "Voltage2" ), pch = 20, col = c( "green", "red" ) )
times <- measurement( seq( from = 0, to = 2, by = 0.1 ), 0 ) # now times is a measurement array with 0 error
times
voltage <- measurement( sqrt( times$val ), 0.1 ) # now voltage is a measurement array with 0.1 error
voltage
plot( times, voltage, pch = 20, cex = 0.5, xlim = c( -1, 3 ), ylim = c( -1, 3 ), xlab = "Time (S)", ylab = "Voltage (V)", main = "Voltage vs Time" )
